const crypto = require('crypto');
const { spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');
const os = require('os');

class SSHKeyService {
  constructor() {
    this.supportedKeyTypes = ['rsa', 'ed25519', 'ecdsa'];
    this.defaultKeySize = {
      rsa: 4096,
      ecdsa: 256
    };
  }

  /**
   * Generate SSH key pair
   * @param {string} keyType - Type of key (rsa, ed25519, ecdsa)
   * @param {number} keySize - Size of the key (for RSA and ECDSA)
   * @param {string} comment - Comment for the key
   * @param {string} passphrase - Optional passphrase for the private key
   */
  async generateKeyPair(keyType = 'rsa', keySize = null, comment = '', passphrase = '') {
    if (!this.supportedKeyTypes.includes(keyType)) {
      throw new Error(`Unsupported key type: ${keyType}. Supported types: ${this.supportedKeyTypes.join(', ')}`);
    }

    const actualKeySize = keySize || this.defaultKeySize[keyType];
    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ssh-keygen-'));
    const privateKeyPath = path.join(tempDir, 'id_' + keyType);
    const publicKeyPath = privateKeyPath + '.pub';

    try {
      // Build ssh-keygen command
      const args = [
        '-t', keyType,
        '-f', privateKeyPath,
        '-N', passphrase || '', // Empty string for no passphrase
        '-C', comment || `Generated by IntelliSSH ${new Date().toISOString()}`
      ];

      // Add key size for RSA and ECDSA
      if (keyType === 'rsa') {
        args.splice(2, 0, '-b', actualKeySize.toString());
      } else if (keyType === 'ecdsa') {
        args.splice(2, 0, '-b', actualKeySize.toString());
      }

      console.log("args:", args)

      // Execute ssh-keygen
      await this.executeCommand('ssh-keygen', args);

      // Read the generated keys
      const privateKey = await fs.readFile(privateKeyPath, 'utf8');
      const publicKey = await fs.readFile(publicKeyPath, 'utf8');

      // Extract public key info
      const publicKeyParts = publicKey.trim().split(' ');
      const keyFingerprint = await this.getKeyFingerprint(publicKeyPath);

      return {
        privateKey: privateKey.trim(),
        publicKey: publicKey.trim(),
        keyType,
        keySize: actualKeySize,
        comment: publicKeyParts[2] || comment,
        fingerprint: keyFingerprint,
        hasPassphrase: !!passphrase
      };
    } finally {
      // Clean up temporary files
      try {
        await fs.unlink(privateKeyPath).catch(() => {});
        await fs.unlink(publicKeyPath).catch(() => {});
        await fs.rmdir(tempDir).catch(() => {});
      } catch (error) {
        console.warn('Failed to cleanup temporary SSH key files:', error.message);
      }
    }
  }

  /**
   * Get SSH key fingerprint
   * @param {string} keyPath - Path to the key file
   */
  async getKeyFingerprint(keyPath) {
    try {
      const result = await this.executeCommand('ssh-keygen', ['-l', '-f', keyPath]);
      return result.stdout.split(' ')[1]; // Extract fingerprint part
    } catch (error) {
      console.warn('Failed to get key fingerprint:', error.message);
      return null;
    }
  }

  /**
   * Validate SSH private key format
   * @param {string} privateKey - The private key string
   */
  validatePrivateKey(privateKey) {
    const validHeaders = [
      '-----BEGIN OPENSSH PRIVATE KEY-----',
      '-----BEGIN RSA PRIVATE KEY-----',
      '-----BEGIN EC PRIVATE KEY-----',
      '-----BEGIN PRIVATE KEY-----'
    ];

    const validFooters = [
      '-----END OPENSSH PRIVATE KEY-----',
      '-----END RSA PRIVATE KEY-----',
      '-----END EC PRIVATE KEY-----',
      '-----END PRIVATE KEY-----'
    ];

    const hasValidHeader = validHeaders.some(header => privateKey.includes(header));
    const hasValidFooter = validFooters.some(footer => privateKey.includes(footer));

    return hasValidHeader && hasValidFooter;
  }

  /**
   * Parse SSH public key to get information
   * @param {string} publicKey - The public key string
   */
  parsePublicKey(publicKey) {
    try {
      const parts = publicKey.trim().split(' ');
      if (parts.length < 2) {
        throw new Error('Invalid public key format');
      }

      const keyType = parts[0];
      const keyData = parts[1];
      const comment = parts.slice(2).join(' ') || '';

      // Determine key type from the algorithm identifier
      let algorithm = 'unknown';
      if (keyType.includes('rsa')) algorithm = 'rsa';
      else if (keyType.includes('ed25519')) algorithm = 'ed25519';
      else if (keyType.includes('ecdsa')) algorithm = 'ecdsa';

      return {
        algorithm,
        keyType,
        keyData,
        comment,
        length: keyData.length
      };
    } catch (error) {
      throw new Error(`Failed to parse public key: ${error.message}`);
    }
  }

  /**
   * Generate SSH key pair using Node.js crypto (fallback)
   * @param {string} keyType - Type of key (rsa, ed25519)
   * @param {number} keySize - Size of the key
   * @param {string} passphrase - Optional passphrase
   */
  async generateKeyPairFallback(keyType = 'rsa', keySize = 4096, passphrase = '') {
    return new Promise((resolve, reject) => {
      const options = {
        modulusLength: keySize,
        publicKeyEncoding: {
          type: 'spki',
          format: 'pem'
        },
        privateKeyEncoding: {
          type: 'pkcs8',
          format: 'pem'
        }
      };

      if (passphrase) {
        options.privateKeyEncoding.cipher = 'aes-256-cbc';
        options.privateKeyEncoding.passphrase = passphrase;
      }

      crypto.generateKeyPair(keyType, options, (err, publicKey, privateKey) => {
        if (err) {
          reject(err);
          return;
        }

        // Convert to SSH format (this is a simplified version)
        resolve({
          privateKey,
          publicKey,
          keyType,
          keySize,
          hasPassphrase: !!passphrase,
          note: 'Generated using Node.js crypto (OpenSSH format conversion may be needed)'
        });
      });
    });
  }

  /**
   * Execute command and return promise
   * @param {string} command - Command to execute
   * @param {string[]} args - Command arguments
   */
  executeCommand(command, args) {
    return new Promise((resolve, reject) => {
      const process = spawn(command, args);
      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        if (code === 0) {
          resolve({ stdout, stderr, code });
        } else {
          reject(new Error(`Command failed with code ${code}: ${stderr || stdout}`));
        }
      });

      process.on('error', (error) => {
        reject(new Error(`Failed to start command: ${error.message}`));
      });
    });
  }

  /**
   * Check if ssh-keygen is available
   */
  async isSSHKeygenAvailable() {
    try {
      await this.executeCommand('which', ['ssh-keygen']);
      return true;
    } catch (error) {
      return false;
    }
  }
}

module.exports = new SSHKeyService();